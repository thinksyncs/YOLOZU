\chapter{Manifest-Driven Operations and Manual Synchronization}

\ChapterMeta{
This chapter establishes \path{tools/manifest.json} as the canonical operational source for commands, input/output (I/O) contracts, and write-side effects.
}{
It mitigates documentation drift by ensuring that manual updates remain strictly traceable to machine-readable tool metadata.
}{
Consult this chapter when introducing new tools, modifying CLI flags, or revising workflows that rely on specific artifact paths and contracts.
}

\section{The Necessity of a Dedicated Chapter}
As the repository's tool surface expands, command examples embedded within narrative chapters are prone to becoming obsolete. A dedicated, manifest-driven workflow guarantees that:
\begin{itemize}
  \item Command discovery originates from a single, authoritative source.
  \item I/O contracts and side effects undergo consistent, systematic review.
  \item Manual chapter revisions are executed synchronously with codebase modifications.
\end{itemize}

\section{Canonical Sources and Hierarchy}
When resolving discrepancies, adhere to the following priority hierarchy:
\begin{enumerate}
  \item \path{tools/manifest.json} (The canonical, machine-readable tool metadata).
  \item Tool \cmd{--help} output (The runtime source of truth for CLI flags).
  \item Chapter prose and examples (Derived, human-readable documentation).
\end{enumerate}

Relevant supplementary references include:
\begin{itemize}
  \item \path{docs/manifest_declarative_spec.md}
  \item \path{docs/tools_index.md}
  \item \path{tools/validate_tool_manifest.py}
\end{itemize}

\section{Mandatory Update Procedure}
When altering tool behavior, you must follow this sequential procedure:
\begin{enumerate}
  \item Implement the requisite code changes.
  \item Update the corresponding tool entry within \path{tools/manifest.json}. Ensure that all new flags, inputs, and outputs are explicitly declared.
  \item Validate the manifest structure and constraints:
\begin{lstlisting}[language=bash]
python3 tools/validate_tool_manifest.py --manifest tools/manifest.json --require-declarative
\end{lstlisting}
  \item Revise the impacted manual chapters located under \path{manual/chapters/}.
  \item Cross-reference and verify all documentation examples against the manifest's \texttt{examples[].command} fields.
\end{enumerate}

\section{Verification Criteria for Manual Updates}
For each affected command family, rigorously verify the following:
\begin{itemize}
  \item The referenced command exists within the manifest under \texttt{id} and \texttt{entrypoint}.
  \item All required input flags accurately reflect the manifest's \texttt{inputs[]} array.
  \item Output declarations and write-path statements align with the \texttt{outputs[]} and \texttt{effects} definitions.
  \item Contract claims strictly match the \texttt{contracts.consumes} and \texttt{contracts.produces} specifications.
\end{itemize}

\section{Understanding Manifest Capabilities}
The manifest is not merely a list of scripts; it is a declarative governance tool. By inspecting \path{tools/manifest.json}, users can ascertain:
\begin{itemize}
  \item \textbf{Platform Compatibility}: The \texttt{platform} object indicates whether a tool requires a GPU (\texttt{gpu\_required}) or supports macOS/Linux.
  \item \textbf{Dependencies}: The \texttt{requires} object lists necessary Python packages and system-level dependencies (e.g., TensorRT).
  \item \textbf{Data Contracts}: The \texttt{contracts} object defines what standard JSON schemas a tool consumes or produces (e.g., \texttt{predictions\_json}, \texttt{metrics\_report\_json}), enabling automated pipeline construction.
\end{itemize}

\section{Quick Audit Commands}
To list all registered tools and their entrypoints:
\begin{lstlisting}[language=bash]
python3 - <<'PY'
import json
with open("tools/manifest.json", "r", encoding="utf-8") as f:
    manifest = json.load(f)
for tool in manifest.get("tools", []):
    print(f"{tool.get('id')} -> {tool.get('entrypoint')}")
PY
\end{lstlisting}

To identify tools that produce a specific contract (e.g., \texttt{eval\_suite\_report\_json}):
\begin{lstlisting}[language=bash]
python3 - <<'PY'
import json
with open("tools/manifest.json", "r", encoding="utf-8") as f:
    manifest = json.load(f)
for tool in manifest.get("tools", []):
    produces = (tool.get("contracts") or {}).get("produces", [])
    if "eval_suite_report_json" in produces:
        print(tool.get("id"))
PY
\end{lstlisting}

\section{Chapter Ownership and Routing}
Utilize this heuristic mapping to determine which chapters require updates following a tool modification:
\begin{itemize}
  \item General CLI changes: Chapter 4
  \item Training, backbone, or run-contract modifications: Chapter 7
  \item Evaluation protocols and benchmark adjustments: Chapter 9
  \item Test-Time Training (TTT) methods and benchmarks: Chapter 15
  \item Registry, contract metadata, and governance changes: Chapter 12 and this chapter
\end{itemize}

This mapping is intentionally lightweight. If a tool modification spans multiple domains, update all affected chapters within the same pull request to maintain documentation coherence.

\section{Ownership split: GitHub docs vs PDF manual}
To avoid double maintenance:
\begin{itemize}
  \item Keep \path{docs/README.md} as an \textbf{index/entry page} with links only.
  \item Keep procedural depth and operational nuance in chapter docs and \path{manual/chapters/}.
  \item When overlap is unavoidable, prefer a single canonical page and link to it from all other surfaces.
\end{itemize}
