\chapter{Tool Registry and Automation (Research Use)}

\ChapterMeta{
This chapter elucidates the machine-readable tool registry (comprising the manifest and schemas) and its role in facilitating safe discovery and execution for both human operators and autonomous agents.
}{
It underpins reproducible automation and Continuous Integration (CI)-style workflows by strictly pinning tool I/O contracts and validating the registry's surface area.
}{
This documentation assumes that tools are invoked exclusively via their declared entrypoints and validated using \cmd{python3 tools/validate_tool_manifest.py}. Path-resolution rules are critical for robust automation.
}

\section{The Rationale for a Tool Registry}
Research workflows frequently accumulate disparate scripts. \yolozu{} addresses this by treating the \path{tools/} directory as a stable, scriptable interface layer, augmented by a machine-readable registry:
\begin{itemize}
  \item \textbf{Tool Manifest}: \path{tools/manifest.json}
  \item \textbf{Manifest Schema}: \path{docs/schemas/tools_manifest.schema.json}
  \item \textbf{Validator}: \cmd{python3 tools/validate_tool_manifest.py}
\end{itemize}

This architecture is explicitly designed to serve:
\begin{itemize}
  \item \textbf{Human Operators}: Providing a clear answer to "What command do I run to achieve X?"
  \item \textbf{Agentic Automation}: Enabling safe, programmatic discovery of entrypoints and I/O contracts.
  \item \textbf{CI-Style Reproducibility}: Ensuring stable commands and deterministic artifact generation.
\end{itemize}

\section{Authority and the Update Imperative}
For CLI capabilities and tool I/O behavior, \path{tools/manifest.json} serves as the \textbf{authoritative source of truth}. Manual documentation must be synchronized from the manifest, rather than maintained as an independent, potentially divergent list.

In the event of a discrepancy:
\begin{itemize}
  \item \textbf{Behavioral Truth}: Resides in the code and the manifest.
  \item \textbf{Documentation Action}: Update this manual chapter and any related chapters to reflect the manifest.
  \item \textbf{Quality Gate}: Re-run the manifest validator prior to publishing any changes.
\end{itemize}

Execute the following command to verify compliance:
\begin{lstlisting}[language=bash]
python3 tools/validate_tool_manifest.py --manifest tools/manifest.json --require-declarative
\end{lstlisting}

\section{Declarative Fields: Mandatory Tool Metadata}
The manifest functions as a declarative contract. At a practical minimum, every tool entry must expose:
\begin{itemize}
  \item \textbf{Identity and Execution}: \texttt{id}, \texttt{entrypoint}, \texttt{runner}, and \texttt{summary}.
  \item \textbf{Environment}: \texttt{platform} constraints and optional \texttt{requires} dependencies.
  \item \textbf{Interface}: Explicit \texttt{inputs[]} and \texttt{outputs[]} definitions.
  \item \textbf{Side Effects}: Declared \texttt{effects.writes[]} and \texttt{effects.fixed\_writes[]}.
  \item \textbf{Reproducibility}: At least one functional \texttt{examples[].command}.
  \item \textbf{Typing and Compatibility}: \texttt{contracts.consumes} and \texttt{contracts.produces}, alongside optional \texttt{contract\_outputs} and \texttt{docs[]} references.
\end{itemize}

For comprehensive field-level policies and boundaries, consult \path{docs/manifest_declarative_spec.md}.

\section{Contracts Referenced by the Manifest}
The manifest references stable JSON schemas located under \path{docs/schemas/}. Prominent schemas include:
\begin{itemize}
  \item \textbf{Predictions}: \path{docs/schemas/predictions.schema.json}
  \item \textbf{Evaluation Suite Reports}: \path{docs/schemas/eval_suite_report.schema.json}
  \item \textbf{COCO Evaluation Reports}: \path{docs/schemas/coco_eval_report.schema.json}
  \item \textbf{Segmentation}: Schemas for both semantic and instance segmentation predictions and evaluation reports.
\end{itemize}

In a research context, these schemas are invaluable as they drastically reduce the overhead required to:
\begin{itemize}
  \item Parse and aggregate results across numerous experimental runs.
  \item Construct dashboards and visualizations from JSONL histories.
  \item Implement assertions (regression gates) against strictly typed outputs.
\end{itemize}

\section{The Discovery Loop}
A recommended practical loop when onboarding to the repository (or returning after an absence):
\begin{enumerate}
  \item Review the documentation index: \path{docs/README.md}.
  \item Scan the tool index: \path{docs/tools_index.md}.
  \item Query the manifest by \texttt{tags}, \texttt{id}, and \texttt{contracts}.
  \item Execute the validator to ensure the registry remains trustworthy.
\end{enumerate}

\subsection*{Practical Manifest Queries}
\begin{lstlisting}[language=bash]
# List all tool IDs and their corresponding entrypoints
python3 - <<'PY'
import json
with open("tools/manifest.json", "r", encoding="utf-8") as f:
    manifest = json.load(f)
for tool in manifest.get("tools", []):
    print(f"{tool.get('id')}\t{tool.get('entrypoint')}")
PY

# Identify tools that consume the 'predictions_json' contract
python3 - <<'PY'
import json
with open("tools/manifest.json", "r", encoding="utf-8") as f:
    manifest = json.load(f)
for tool in manifest.get("tools", []):
    consumes = (tool.get("contracts") or {}).get("consumes", [])
    if "predictions_json" in consumes:
        print(tool.get("id"))
PY
\end{lstlisting}

\section{AI-First Entrypoints for Autonomous Agents}
For autonomous or semi-autonomous operations, the recommended stable entrypoints are:
\begin{itemize}
  \item \textbf{Unified Wrapper}: \cmd{python3 tools/yolozu.py --help}
  \item \textbf{Tool Registry}: \path{tools/manifest.json}
  \item \textbf{Contracts and Schemas}: \path{docs/schemas/*.schema.json}
  \item \textbf{Usage Guide}: \path{docs/ai_first.md}
\end{itemize}

This represents an explicit design objective of \yolozu{}: AI agents must be capable of discovering, validating, executing, and extending workflows utilizing stable, well-defined contracts.

\section{Manifest-Synchronized Documentation Workflow}
When introducing or modifying a tool, adhere to the following workflow:
\begin{enumerate}
  \item Update the script's behavior within \path{tools/} and ensure the CLI help output remains accurate.
  \item Update \path{tools/manifest.json} to reflect changes in inputs, effects, outputs, examples, and contracts.
  \item Validate the manifest's structure and internal references.
  \item Revise the corresponding manual chapter sections and examples.
  \item Maintain synchronization of documentation links (e.g., \path{docs/README.md}, \path{docs/tools_index.md}).
\end{enumerate}

This rigorous process keeps manual chapters aligned with the registry, thereby minimizing stale command drift.

Validate the tool registry using:
\begin{lstlisting}[language=bash]
python3 tools/validate_tool_manifest.py --manifest tools/manifest.json --require-declarative
\end{lstlisting}

\section{Path Resolution Behavior (Critical for Automation)}
Many tools adhere to consistent path resolution rules (summarized in \path{docs/tools_index.md} and \path{docs/ai_first.md}):
\begin{itemize}
  \item CLI-relative input paths resolve from the current working directory.
  \item Config-relative paths (where supported) resolve from the directory containing the configuration file.
  \item Relative outputs are written relative to the current working directory.
\end{itemize}

\section{Safety Guardrails for Agentic Write Actions}
Prior to writing artifacts or mutating state, agents and users should prioritize:
\begin{itemize}
  \item Utilizing \textbf{dry-run modes} wherever available.
  \item Applying \textbf{explicit caps or ranges} (e.g., \cmd{--max-images}) to limit execution scope.
  \item Directing outputs to \textbf{deterministic locations}, such as under \path{reports/} or a dedicated run directory.
\end{itemize}

In a research environment, these practices ensure that batch operations run reliably across different working directories and enhance the portability of scripted executions.
