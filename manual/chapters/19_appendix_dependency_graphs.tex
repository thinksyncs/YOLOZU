\chapter{Appendix: Code Graphs (Entry Points and Imports)}

\ChapterMeta{
This appendix provides two views of the repository's Python code relationships: (1) a human-oriented entry-point map, and (2) an auto-extracted import dependency graph (internal modules only).
}{
The goal is to reduce onboarding cost by making the "where does this run from" and "what depends on what" structure visible in the PDF.
}{
The import graphs are generated by \path{tools/generate_manual_import_graphs.py}. Graphviz is optional: the manual renders graphs via TikZ so the build does not require \cmd{dot}.
}

\section{Repository entry points (high level)}
This diagram focuses on how users (and agents) typically enter the system, how execution flows into adapters/runtimes, and which contracts/artifacts are emitted.

\begin{figure}[h]
\centering
\resizebox{\linewidth}{!}{%
\begin{tikzpicture}[
  node distance=10mm,
  font=\small,
  box/.style={draw, rounded corners, align=left, inner sep=6pt},
  group/.style={draw, rounded corners, inner sep=8pt},
  arrow/.style={-{Latex[length=2mm]}, thick}
]

% Left: entry points
\node[box] (cli) {\textbf{Entry points}\\
\cmd{tools/yolozu.py}\\
\cmd{tools/export_predictions.py}\\
\cmd{rtdetr_pose.train_minimal} (dev)};

% Middle: core layers
\node[box, right=18mm of cli] (manifest) {\textbf{Tool registry}\\\path{tools/manifest.json}\\validator: \path{tools/validate_tool_manifest.py}};

\node[box, below=10mm of manifest] (adapter) {\textbf{Adapter / model scaffold}\\
\path{rtdetr_pose/*}\\
(backbone, projector, encoder, export)};

\node[box, below=10mm of adapter] (tta) {\textbf{TTT / TTA (optional)}\\
Tent / MIM / CoTTA / EATA / SAR\\
(update filter + guard rails)};

% Right: artifacts
\node[box, right=20mm of manifest] (contracts) {\textbf{Contracts / schemas}\\
\path{docs/schemas/*.schema.json}\\
run-contract + predictions schema};

\node[box, below=10mm of contracts] (artifacts) {\textbf{Artifacts}\\
\path{predictions.json}\\
run logs / reports\\
exported ONNX (+ meta)};

% Connections
\draw[arrow] (cli) -- (manifest);
\draw[arrow] (cli) -- (adapter);
\draw[arrow] (adapter) -- (contracts);
\draw[arrow] (adapter) -- (artifacts);
\draw[arrow] (tta) -- (adapter);
\draw[arrow] (tta) -- (artifacts);

% Group boxes
\node[group, fit=(cli), label={[align=left]above:Human/agent execution}] {};
\node[group, fit=(manifest) (adapter) (tta), label={[align=left]above:Python modules}] {};
\node[group, fit=(contracts) (artifacts), label={[align=left]above:Outputs and interfaces}] {};

\end{tikzpicture}
}
\caption{Entry-point map and major code layers.}
\end{figure}

\clearpage
\section{Python import dependency graph (internal)}
The following graph is auto-extracted from Python \cmd{import} statements. It is intentionally restricted to internal modules and summarized at the package level to keep the PDF readable.

Arrow semantics: an edge $A \to B$ means \textbf{$A$ imports $B$} (i.e., $A$ depends on $B$).

\begin{figure}[h]
\centering
\input{figures/import_deps_packages.tikz}
\caption{Internal Python import dependencies (package-level summary).}
\end{figure}

\subsection{Graph source (DOT)}
The DOT source used to generate the package-level dependency summary is included for auditability:

\lstinputlisting[language=bash,breaklines=true,breakatwhitespace=false]{figures/import_deps_packages.dot}
